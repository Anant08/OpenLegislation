package gov.nysenate.openleg.service.spotcheck.base;

import gov.nysenate.openleg.model.spotcheck.DeNormSpotCheckMismatch;
import gov.nysenate.openleg.model.spotcheck.SpotCheckMismatchIgnore;
import gov.nysenate.openleg.model.spotcheck.SpotCheckMismatchStatus;
import gov.nysenate.openleg.model.spotcheck.SpotCheckMismatchType;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Service
public class MismatchStatusService {

    /**
     * Derives the correct mismatch status for a new mismatch by comparing it to current mismatches.
     *
     * @param reportMismatches  New mismatches generated by a report.
     * @param currentMismatches All the most recent mismatches for the datasource checked by the report.
     * @return List of DeNormSpotCheckMismatches with their statuses updated to an appropriate value.
     */
    public static List<DeNormSpotCheckMismatch> deriveStatuses(List<DeNormSpotCheckMismatch> reportMismatches,
                                                               List<DeNormSpotCheckMismatch> currentMismatches) {
        List<DeNormSpotCheckMismatch> newMismatches = reportMismatches.stream()
                .filter(m -> !currentMismatches.contains(m))
                .peek(m -> m.setStatus(SpotCheckMismatchStatus.NEW))
                .collect(Collectors.toList());

        List<DeNormSpotCheckMismatch> existingMismatches = reportMismatches.stream()
                .filter(currentMismatches::contains)
                .peek(m -> m.setStatus(calculateStatus(currentMismatches.get(currentMismatches.indexOf(m)))))
                .peek(m -> m.setIgnoreStatus(calculateIgnoreStatus(currentMismatches.get(currentMismatches.indexOf(m)))))
                .collect(Collectors.toList());

        return Stream.concat(newMismatches.stream(), existingMismatches.stream()).collect(Collectors.toList());
    }

    private static SpotCheckMismatchStatus calculateStatus(DeNormSpotCheckMismatch currMismatch) {
        if (currMismatch.getStatus() == SpotCheckMismatchStatus.RESOLVED || currMismatch.getStatus() == SpotCheckMismatchStatus.REGRESSION) {
            return SpotCheckMismatchStatus.REGRESSION;
        } else {
            return SpotCheckMismatchStatus.EXISTING;
        }
    }

    private static SpotCheckMismatchIgnore calculateIgnoreStatus(DeNormSpotCheckMismatch currMismatch) {
        if (currMismatch.getIgnoreStatus() == SpotCheckMismatchIgnore.NOT_IGNORED || currMismatch.getIgnoreStatus() == SpotCheckMismatchIgnore.IGNORE_ONCE) {
            return SpotCheckMismatchIgnore.NOT_IGNORED;
        }
        return currMismatch.getIgnoreStatus();
    }

    /**
     * Returns a list of mismatches that have been resolved by a spotcheck report.
     * Mismatches are resolved if they were checked by the report (in checkedKeys and checkedTypes),
     * are not in the report mismatches and are not already resolved.
     *
     * @param reportMismatches  New mismatches generated by a report.
     * @param currentMismatches All the most recent mismatches for the datasource checked by the report.
     * @param checkedKeys       All contentKey's checked by the report.
     * @param checkedTypes      All SpotCheckMismatchType's checked by the report.
     * @return A list of mismatches resolved by this report.
     */
    public static List<DeNormSpotCheckMismatch> deriveResolved(List<DeNormSpotCheckMismatch> reportMismatches,
                                                               List<DeNormSpotCheckMismatch> currentMismatches,
                                                               Set<Object> checkedKeys,
                                                               Set<SpotCheckMismatchType> checkedTypes) {
        return currentMismatches.stream()
                .filter(m -> !reportMismatches.contains(m))
                .filter(m -> checkedKeys.contains(m.getKey()))
                .filter(m -> checkedTypes.contains(m.getMismatchType()))
                .filter(m -> m.getStatus() != SpotCheckMismatchStatus.RESOLVED)
                .peek(m -> m.setStatus(SpotCheckMismatchStatus.RESOLVED))
                .peek(m -> m.setIgnoreStatus(calculateIgnoreStatusForResolved(m)))
                .collect(Collectors.toList());
    }

    private static SpotCheckMismatchIgnore calculateIgnoreStatusForResolved(DeNormSpotCheckMismatch currMismatch) {
        if (currMismatch.getIgnoreStatus() == SpotCheckMismatchIgnore.IGNORE_PERMANENTLY) {
            return SpotCheckMismatchIgnore.IGNORE_PERMANENTLY;
        }
        return SpotCheckMismatchIgnore.NOT_IGNORED;
    }

}
