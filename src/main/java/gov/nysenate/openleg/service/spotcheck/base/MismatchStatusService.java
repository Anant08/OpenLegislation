package gov.nysenate.openleg.service.spotcheck.base;

import gov.nysenate.openleg.model.spotcheck.DeNormSpotCheckMismatch;
import gov.nysenate.openleg.model.spotcheck.SpotCheckMismatchStatus;
import gov.nysenate.openleg.model.spotcheck.SpotCheckMismatchType;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;

@Service
public class MismatchStatusService {

    /**
     * Derives the correct mismatch status for a new mismatch by comparing it to current mismatches.
     * This method modifies the mismatches contained in reportMismatches.
     *
     * @param reportMismatches New mismatches generated by a report.
     * @param currentMismatches All the most recent mismatches for the datasource checked by the report.
     * @return List of DeNormSpotCheckMismatches with their statuses updated to an appropriate value.
     */
    public static List<DeNormSpotCheckMismatch> deriveStatuses(List<DeNormSpotCheckMismatch> reportMismatches,
                                                               final List<DeNormSpotCheckMismatch> currentMismatches) {
        for (DeNormSpotCheckMismatch reportMm : reportMismatches) {
            if (currentMismatches.contains(reportMm)) {
                if (currentMismatchResolvedOrRegression(currentMismatches, reportMm)) {
                    reportMm.setStatus(SpotCheckMismatchStatus.REGRESSION);
                } else {
                    reportMm.setStatus(SpotCheckMismatchStatus.EXISTING);
                }
            }
            else {
                reportMm.setStatus(SpotCheckMismatchStatus.NEW);
            }
        }
        return reportMismatches;
    }

    private static boolean currentMismatchResolvedOrRegression(List<DeNormSpotCheckMismatch> currentMismatches, DeNormSpotCheckMismatch reportMm) {
        DeNormSpotCheckMismatch mismatch = currentMismatches.get(currentMismatches.indexOf(reportMm));
        return mismatch.getStatus() == SpotCheckMismatchStatus.RESOLVED || mismatch.getStatus() == SpotCheckMismatchStatus.REGRESSION;
    }

    /**
     * Returns a list of mismatches that have been resolved by a spotcheck report.
     * Mismatches are resolved if they were checked by the report (in checkedKeys and checkedTypes)
     * and the report did not generate a mismatch (not in reportMismatches).
     * @param reportMismatches New mismatches generated by a report.
     * @param currentMismatches All the most recent mismatches for the datasource checked by the report.
     * @param checkedKeys All contentKey's checked by the report.
     * @param checkedTypes All SpotCheckMismatchType's checked by the report.
     * @return A list of mismatches resolved by this report.
     */
    public static List<DeNormSpotCheckMismatch> deriveResolved(final List<DeNormSpotCheckMismatch> reportMismatches,
                                                               final List<DeNormSpotCheckMismatch> currentMismatches,
                                                               final Set<Object> checkedKeys,
                                                               final Set<SpotCheckMismatchType> checkedTypes) {
        List<DeNormSpotCheckMismatch> resolvedMm = new ArrayList<>();
        for (DeNormSpotCheckMismatch currentMm : currentMismatches) {
            if (!reportMismatches.contains(currentMm)) {
                if (checkedKeys.contains(currentMm.getKey()) && checkedTypes.contains(currentMm.getMismatchType())) {
                    currentMm.setStatus(SpotCheckMismatchStatus.RESOLVED);
                    resolvedMm.add(currentMm);
                }
            }
        }
        return resolvedMm;
    }
}
